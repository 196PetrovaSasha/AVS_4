# AVS_4

### Боссерт Александра БПИ219
### Вариант 1

#### Условия

 В тихом городке есть парикмахерская. Салон парикмахерской мал, работать в нем нем может только один парикмахер, обслуживающий одного посетителя. Есть несколько кресел для ожидания в очереди. Парикмахер всю жизнь обслуживает посетителей. Когда в салоне никого нет, он спит в кресле. Когда посетитель приходит и видит спящего парикмахера, он будет его, садится в кресло, «засыпая» на тот момент, пока парикмахер обслуживает его. Если посетитель приходит, а парикмахер занят, то он
встает в очередь и «засыпает». После стрижки парикмахер сам провожает посетителя. Если есть ожидающие посетители, то парикмахер будит одного из
них и ждет пока тот сядет в кресло парикмахера и начинает стрижку. Если никого нет, он снова садится в свое кресло и засыпает до прихода посетителя. Создать многопоточное приложение, моделирующее рабочий день парикмахерской.

#### Вводимые параметры
Chairs - количество мест у парикмахера

#### Модель многопоточности
Планировщик распределяет процессорное время между разными потоками. Это называется аппаратным параллелизмом или аппаратной конкурентностью (пока что считаем здесь параллелизм и конкурентность синонимами): когда несколько потоков выполняются на разных ядрах параллельно, причём каждый занимается конкретной задачей программы.

#### Модель поведения субъектов
Нам нужно создать модель поведения парикмахера для указанной задачи. Мы создаем два потока, отвечающие за поведение парикмахера и клиента. 

Поток парикмахера:
Пускаем бесконечный цикл, так как работа не прекратится, пока мы ее не остановим. Смотрим на очередь гостей, если никого нет - парикмахер отправляется спать. Если приходит клиент, мы будим парикмахера. Он забирает клиента из очереди (клиент при этом удаляется) и стрижет его.
```

void* customer_thread(void* params) {

    pthread_mutex_lock(&mutex);
    int custNumber = rand() % 1000 + 1;
    customer_t cust {
            custNumber, 0
    };
    cout << "[customer] I am new customer #" << custNumber << " | " << line.size() <<" people before me!\n";
    if (infl) {
        MyFile << "[customer] I am new customer #" << custNumber << " | " << line.size() <<" people before me!\n";
    }
    if (line.size() > CHAIR_COUNT) {
        //Мест нет
        cout << "[customer] No place for me in queue #"<< custNumber << "\n";
        if (infl) {
            MyFile << "[customer] No place for me in queue #"<< custNumber << "\n";
        }
        pthread_mutex_unlock(&mutex);
        return 0;
    }
    line.push(cust);
    pthread_mutex_unlock(&mutex);
    //Места есть, парикмахер делает стрижку
    sem_wait(&barber);
    cout << "[customer] Got the haircut #" << custNumber << "\n";
    if (infl) {
        MyFile << "[customer] Got the haircut #" << custNumber << "\n";
    }
    return 0;
}
```

Поток клиента:
Приходит клиент, смотрит сколько людей перед ним. Если очередь больше, чем мест, клиент уходит, если нет - встает очередь. Как только парикмахер обслужит всех предыдущих клиентов - клиента стригут.

```

void* barber_thread(void* params) {

    while(true) {
        pthread_mutex_lock(&mutex);

        if (line.empty()) {
            //Никого нет, можно поспать
            pthread_mutex_unlock(&mutex);
            if (!barberSleep) {
                cout << "[barber] Barber sleep\n";
                if (infl) {
                    MyFile << "[barber] Barber sleep\n";
                }
                barberSleep = true;
            }

            sleep(5);
            continue;
        }
        //Барбер просыпается
        if (barberSleep) {
            barberSleep = false;
            cout << "[barber] Barber awake!\n";
            if (infl) {
                MyFile << "[barber] Barber awake!\n";
            }
        }
        //Берет первого человека в очереди
        customer_t cust = line.front();
        //Удаляем клиента из списка, ему место в очереди больше не нужно
        line.pop();
        pthread_mutex_unlock(&mutex);
        cout << "[barber] Processing customer #" << cust.index << "\n";
        if (infl) {
            MyFile << "[barber] Processing customer #" << cust.index << "\n";
        }
        sleep(rand() % 3 + 5);
        sem_post(&barber);
        sleep(5);
    }
    return 0;
}
```

Основная программа:
Мы вводим каким образом программа получает количество мест:
1. Через консоль
2. Через файл (выводв такой случае тоже в файл)
3. Генерируется случайное число

Далее мы запускаем работу парикмахера и в бесконечном цикле генерируем клиентов, запуская параллельно поток с каждым новым клиентом.

Дополнительные поля и структуры:

struct customer_t - структура клиента, определяет его место в очереди и статус

pthread_mutex_t mutex - используется для реализации взаимного исключения процесса

sem_t barber - семафор, который заставляет клиента ждать окончания стрижки

bool barberSleep - параметр, определяющий спит парикмахер или нет

queue<customer_t> line - очередь клиентов

bool infl - определяет, выводим результат в файл или нет


Для написания данного задания были использованы следующие библиотеки:
```

#include <iostream>

#include <pthread.h>

#include <semaphore.h>

#include <time.h>

#include <unistd.h>

#include <fstream>

#include <cstring>

#include <vector>

#include <queue>
```

Из которых библиотеки pthread и semafore отвечали за параллельную работу потоков парикмахера и клиентов.

#### Способы ввода параметра:

##### Через консоль

Вводится одно число - количетсво стульев.

Вывод происходит в консоль

##### Через файл:

В файл input.txt вводится одно число - количество стульев.

Путь к файлу: \AVS_HM\cmake-build-debug\input.txt

Вывод происходит в файл output.txt

Путь к файлу: \AVS_HM\cmake-build-debug\output.txt

##### С помощью генерации псевдослучайного числа:

Генерируется одно случайное число - количество стульев.

Ввод производится в консоль.

### Результат проделанной работы 
Реализовано многопоточное приложение, работающее на системе Linux. Проведены тестовые запуски, с целью устранения ошибок. Реализовано несколько способов ввода параметра  и выполнен отчет о проделанной работе.


##### Хорошего дня!



